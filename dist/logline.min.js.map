{"version":3,"file":"logline.min.js","sources":["../src/lib/config.js","../src/lib/util.js","../src/protocols/interface.js","../src/lib/pool.js","../src/protocols/indexeddb.js","../src/protocols/localstorage.js","../src/logline.js"],"sourcesContent":["const DEFAULT_CONFIG = {\r\n    verbose: true\r\n};\r\n\r\nlet store = Object.assign({}, DEFAULT_CONFIG);\r\n\r\nexport function get(key) {\r\n    return key ? store[key] : store;\r\n}\r\n\r\nexport function set(key, value) {\r\n    let changes = {};\r\n    if (typeof key === 'string') {\r\n        changes[key] = value;\r\n    } else if (Object.prototype.toString.call(key) === '[object Object]') {\r\n        changes = key;\r\n    }\r\n    Object.assign(store, changes);\r\n}\r\n\r\nlet config = set;\r\nconfig.set = set;\r\nconfig.get = get;\r\n\r\nexport default config;\r\n","import config from './config';\r\n\r\nconst HAS_CONSOLE = window.console;\r\nconst LEVEL_CONSOLE_MAP = {\r\n    INFO: 'log',\r\n    WARN: 'warn',\r\n    ERROR: 'error',\r\n    CRITICAL: 'error'\r\n};\r\n\r\n// throw out Errors, with global prefix 'Logline: ' ahead of err.message\r\nexport function throwError(errMessage) {\r\n    HAS_CONSOLE && console.error('Logline: ' + errMessage);\r\n}\r\n\r\n// print debug info in develper's console\r\n// TODO: if WechatFE/vConsole is detected, will not use %c feature, as it is not well supported\r\nexport function debug(namespace, level, descriptor, data) {\r\n    if (HAS_CONSOLE && config.get().verbose) {\r\n        window.console[LEVEL_CONSOLE_MAP[level.toUpperCase()] || LEVEL_CONSOLE_MAP.INFO](new Date().toLocaleString(),`[${namespace}] ${level.toUpperCase()} ${descriptor}`, data || '');\r\n    }\r\n}\r\n\r\n// filter any function in a object\r\nexport function filterFunction(obj) {\r\n    var newObj = {}, i;\r\n\r\n    if (typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    for (i in obj) {\r\n        if (obj.hasOwnProperty(i)) {\r\n            if (typeof obj[i] !== 'function') {\r\n                newObj[i] = filterFunction(obj[i]);\r\n            }\r\n        }\r\n    }\r\n    return newObj;\r\n}\r\n","import * as util from '../lib/util';\r\n\r\n/**\r\n * Logline Interface\r\n * @class Interface\r\n */\r\nexport default class Interface {\r\n    /**\r\n     * Logline constructor\r\n     * @constructor\r\n     * @param {String} namespace - namespace to use\r\n     */\r\n    constructor(namespace) {\r\n        this._namespace = namespace;\r\n    }\r\n\r\n    /**\r\n     * add a log record\r\n     * @method _reocrd\r\n     * @private\r\n     * @parma {String} level - log level\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     * @param {Boolean} [develop] - to tell develop environment from production\r\n     */\r\n    _record(level, descriptor, data, develop) {\r\n        util.throwError('method _record is not implemented.');\r\n    }\r\n\r\n    /**\r\n     * add a level-info record\r\n     * @method info\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     */\r\n    info(...args) {\r\n        this._record('info', ...args);\r\n    }\r\n\r\n    /**\r\n     * add a level-warn record\r\n     * @method warn\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     */\r\n    warn(...args) {\r\n        this._record('warn', ...args);\r\n    }\r\n\r\n    /**\r\n     * add a level-error record\r\n     * @method error\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     */\r\n    error(...args) {\r\n        this._record('error', ...args);\r\n    }\r\n\r\n    /**\r\n     * add a level-critical record\r\n     * @method critical\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     */\r\n    critical(...args) {\r\n        this._record('critical', ...args);\r\n    }\r\n\r\n    /**\r\n     * initialize protocol\r\n     * @method init\r\n     * @static\r\n     * @param {String} database - database name to use\r\n     */\r\n    static init(database) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * transform human readable time string, such as '3d', '.3' and '1.2' into Unix timestamp\r\n     * the default relative time is Date.now(), if no second parameter is provided\r\n     * @method transTimeFormat\r\n     * @static\r\n     * @param {String} time - time string to transform\r\n     * @param {Number} [relative] - relative time to compare, default Date.now()\r\n     * @return {Number|NaN} timestamp transformed\r\n     */\r\n    static transTimeFormat(time, relative) {\r\n        // if falsy value or timestamp already, pass it through directly,\r\n        if (!time || /^\\d{13}$/.test(time)) {\r\n            return +time;\r\n        }\r\n        // incase relative time isn't unix timestamp format,\r\n        // neither a falsy value which will turned out to be Date.now()\r\n        if (relative && !/^\\d{13}$/.test(relative)) {\r\n            throw new TypeError('relative time should be standard unix timestamp');\r\n        }\r\n\r\n        return (relative || Date.now()) - time.replace(/d$/, '') * 24 * 3600 * 1000;\r\n    }\r\n\r\n    /**\r\n     * get logs in range\r\n     * if from and end is not defined, will fetch full log\r\n     * @method get\r\n     * @static\r\n     * @param {String} from - time from, unix timestamp\r\n     * @param {String} to - time end, unix timestamp\r\n     * @param {Function} readyFn - function to call back with logs as parameter\r\n     */\r\n    static get(from, to, readyFn) {\r\n        util.throwError('method get is not implemented.');\r\n    }\r\n\r\n    /**\r\n     * clean logs = keep limited logs\r\n     * @method keep\r\n     * @static\r\n     * @param {Number} daysToMaintain - keep logs within days\r\n     */\r\n    static keep(daysToMaintain) {\r\n        util.throwError('method keep is not implemented.');\r\n    }\r\n\r\n    /**\r\n     * delete log database\r\n     * @method clean\r\n     * @static\r\n     */\r\n    static clean() {\r\n        util.throwError('method clean is not implemented.');\r\n    }\r\n\r\n    /**\r\n     * protocol status map\r\n     * @prop {Object} STATUS\r\n     */\r\n    static get STATUS() {\r\n        return {\r\n            INITING: 1,\r\n            INITED: 2,\r\n            FAILED: 4\r\n        };\r\n    }\r\n}\r\n","/**\r\n * Pool, for storage of async calling\r\n * @class Pool\r\n */\r\nexport default class Pool {\r\n    /**\r\n     * Pool constructor\r\n     * @constructor\r\n     */\r\n    constructor() {\r\n        this._pool = [];\r\n    }\r\n\r\n    /**\r\n     * add an procedure\r\n     * @method push\r\n     * @param {Function} handler - procedure handler\r\n     * @param {Object} context - procedure context\r\n     */\r\n    push(handler, context) {\r\n        handler.context = context;\r\n        this._pool.push(handler);\r\n    }\r\n\r\n    /**\r\n     * consume pool\r\n     * @method consume\r\n     */\r\n    consume() {\r\n        var handler;\r\n        while ((handler = this._pool.shift())) {\r\n            handler.call(handler.context);\r\n        }\r\n    }\r\n}\r\n","import LoggerInterface from './interface';\r\nimport Pool from '../lib/pool';\r\nimport * as util from '../lib/util';\r\n\r\nconst READ_WRITE = 'readwrite';\r\n\r\n/**\r\n * IndexedDB protocol\r\n * @class IndexedDBLogger\r\n */\r\nexport default class IndexedDBLogger extends LoggerInterface {\r\n    /**\r\n     * IndexedDB protocol constructor\r\n     * @constructor\r\n     * @param {String} namespace - namespace to use\r\n     */\r\n    constructor(...args) {\r\n        super(...args);\r\n    }\r\n\r\n    /**\r\n     * add a log record\r\n     * @method _reocrd\r\n     * @private\r\n     * @parma {String} level - log level\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     * @param {Boolean} [develop] - to tell develop environment from production\r\n     */\r\n    _record(level, descriptor, data, develop) {\r\n        try {\r\n            if (IndexedDBLogger.status !== LoggerInterface.STATUS.INITED) {\r\n                IndexedDBLogger._pool.push(() => this._record(level, descriptor, data, develop));\r\n                if (IndexedDBLogger.status !== LoggerInterface.STATUS.INITING) {\r\n                    IndexedDBLogger.init();\r\n                }\r\n                return;\r\n            }\r\n            if (develop) {\r\n                util.debug(this._namespace, level, descriptor, data);\r\n            }\r\n            let transaction = IndexedDBLogger.db.transaction(['logs'], READ_WRITE || 'readwrite');\r\n            transaction.onerror = event => util.throwError(event.target.error);\r\n\r\n            let store = transaction.objectStore('logs');\r\n            // should not contains any function in data\r\n            // otherwise 'DOMException: Failed to execute 'add' on 'IDBObjectStore': An object could not be cloned.' will be thrown\r\n            let request = store.add({\r\n                time: Date.now(),\r\n                level: level,\r\n                namespace: this._namespace,\r\n                descriptor: descriptor,\r\n                data: util.filterFunction(data)\r\n            });\r\n\r\n            request.onerror = event => {\r\n                IndexedDBLogger.status = LoggerInterface.STATUS.FAILED;\r\n                util.throwError(event.target.error);\r\n            };\r\n        } catch (e) {\r\n            util.throwError('failed to write, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * initialize protocol\r\n     * @method init\r\n     * @static\r\n     * @param {String} database - database name to use\r\n     */\r\n    static init(database) {\r\n        try {\r\n            if (!IndexedDBLogger.support) {\r\n                util.throwError('your platform does not support indexeddb protocol.');\r\n            }\r\n\r\n            if (IndexedDBLogger.status) {\r\n                return false;\r\n            }\r\n\r\n            IndexedDBLogger._pool = IndexedDBLogger._pool || new Pool();\r\n            IndexedDBLogger._database = database || 'logline';\r\n            IndexedDBLogger.status = super.STATUS.INITING;\r\n\r\n            IndexedDBLogger.request = window.indexedDB.open(IndexedDBLogger._database);\r\n            IndexedDBLogger.request.onerror = event => util.throwError('protocol indexeddb is prevented.');\r\n            IndexedDBLogger.request.onsuccess = event => {\r\n                IndexedDBLogger.db = event.target.result;\r\n                IndexedDBLogger.status = super.STATUS.INITED;\r\n                IndexedDBLogger._pool.consume();\r\n                // globally handle db request errors\r\n                IndexedDBLogger.db.onerror = event => util.throwError(event.target.error);\r\n            };\r\n            IndexedDBLogger.request.onupgradeneeded = event => {\r\n                // init dabasebase\r\n                let db = event.target.result, store = db.createObjectStore('logs', { autoIncrement: true });\r\n                store.createIndex('namespace', 'namespace', { unique: false });\r\n                store.createIndex('level', 'level', { unique: false });\r\n                store.createIndex('descriptor', 'descriptor', { unique: false });\r\n                store.createIndex('data', 'data', { unique: false });\r\n            };\r\n        } catch (e) {\r\n            util.throwError('failed init, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get logs in range\r\n     * if from and end is not defined, will fetch full log\r\n     * @method get\r\n     * @static\r\n     * @param {String} [from] - time from, unix time stamp or falsy\r\n     * @param {String} [to] - time end, unix time stamp or falsy\r\n     * @param {Function} readyFn - function to call back with logs as parameter\r\n     */\r\n    static get(from, to, readyFn) {\r\n        try {\r\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\r\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.get(from, to, readyFn));\r\n            }\r\n\r\n            from = LoggerInterface.transTimeFormat(from);\r\n            to = LoggerInterface.transTimeFormat(to);\r\n\r\n            let store = IndexedDBLogger._getTransactionStore(IDBTransaction.READ_ONLY);\r\n            if (!store) {\r\n                return readyFn([]);\r\n            }\r\n\r\n            // IDBObjectStore.getAll is a non-standard API\r\n            if (store.getAll) {\r\n                let result, logs = [];\r\n                store.getAll().onsuccess = event => {\r\n                    result = event.target.result;\r\n                    for (let i = 0; i < result.length; i++) {\r\n                        if ((from && result[i].time < from) || (to && result[i].time > to)) {\r\n                            continue;\r\n                        }\r\n                        logs.push(result[i]);\r\n                    }\r\n                    readyFn(logs);\r\n                };\r\n            } else {\r\n                let request = store.openCursor(), logs = [];\r\n                request.onsuccess = event => {\r\n                    var cursor = event.target.result;\r\n                    if (cursor) {\r\n                        if ((from && cursor.value.time < from) || (to && cursor.value.time > to)) {\r\n                            return cursor.continue();\r\n                        }\r\n\r\n                        logs.push({\r\n                            time: cursor.value.time,\r\n                            level: cursor.value.level,\r\n                            namespace: cursor.value.namespace,\r\n                            descriptor: cursor.value.descriptor,\r\n                            data: cursor.value.data\r\n                        });\r\n                        cursor.continue();\r\n                    }\r\n                    else {\r\n                        readyFn(logs);\r\n                    }\r\n                };\r\n            }\r\n        } catch (e) {\r\n            util.throwError('failed to get logs, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * clean logs = keep limited logs\r\n     * @method keep\r\n     * @static\r\n     * @param {Number} daysToMaintain - keep logs within days\r\n     */\r\n    static keep(daysToMaintain) {\r\n        try {\r\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\r\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.keep(daysToMaintain));\r\n            }\r\n\r\n            let store = IndexedDBLogger._getTransactionStore(READ_WRITE);\r\n            if (!store) {\r\n                return false;\r\n            }\r\n            if (!daysToMaintain) {\r\n                let request = store.clear().onerror = event => util.throwError(event.target.error);\r\n            }\r\n            else {\r\n                let range = (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\r\n                let request = store.openCursor();\r\n                request.onsuccess = event => {\r\n                    let cursor = event.target.result;\r\n                    if (cursor && cursor.value.time < range) {\r\n                        store.delete(cursor.primaryKey);\r\n                        cursor.continue();\r\n                    }\r\n                };\r\n                request.onerror = event => util.throwError('unable to locate logs earlier than ' + daysToMaintain + 'd.');\r\n            }\r\n        } catch (e) {\r\n            util.throwError('failed to keep logs, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * delete log database\r\n     * @method clean\r\n     * @static\r\n     */\r\n    static clean() {\r\n        try {\r\n            if (IndexedDBLogger.status !== super.STATUS.INITED) {\r\n                return IndexedDBLogger._pool.push(() => IndexedDBLogger.clean());\r\n            }\r\n\r\n            // database can be removed only after all connections are closed\r\n            IndexedDBLogger.db.close();\r\n            let request = window.indexedDB.deleteDatabase(IndexedDBLogger._database);\r\n            request.onerror = event => util.throwError(event.target.error);\r\n            /* eslint no-unused-vars: \"off\" */\r\n            request.onsuccess = event => {\r\n                delete IndexedDBLogger.status;\r\n                delete IndexedDBLogger.db;\r\n            };\r\n        } catch (e) {\r\n            util.throwError('failed to cleanup logs, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get internal transaction store\r\n     * @method _getTransactionStore\r\n     * @private\r\n     * @static\r\n     * @param {String} mode - transaction mode\r\n     * @return {Object} - internal object store\r\n     */\r\n    static _getTransactionStore(mode) {\r\n        try {\r\n            if (IndexedDBLogger.db) {\r\n                let transaction = IndexedDBLogger.db.transaction(['logs'], mode || READ_WRITE);\r\n                transaction.onerror = event => util.throwError(event.target.error);\r\n                return transaction.objectStore('logs');\r\n            }\r\n            else {\r\n                util.throwError('log database is not created or connections are closed, considering init it.');\r\n            }\r\n        } catch (e) {\r\n            util.throwError('failed to generate new transaction, ' + e.message);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * detect support situation\r\n     * @prop {Boolean} support\r\n     */\r\n    static get support() {\r\n        const support = !!(window.indexedDB && window.IDBTransaction && window.IDBKeyRange);\r\n        return support;\r\n    }\r\n}\r\n","import LoggerInterface from './interface';\r\nimport * as util from '../lib/util';\r\n\r\n/**\r\n * Localstorage protocol\r\n * @class LocalStorageLogger\r\n */\r\nexport default class LocalStorageLogger extends LoggerInterface {\r\n    /**\r\n     * Localstorage protocol constructor\r\n     * @constructor\r\n     * @param {String} namespace - namespace to use\r\n     */\r\n    constructor(...args) {\r\n        super(...args);\r\n    }\r\n\r\n    /**\r\n     * add a log record\r\n     * @method _reocrd\r\n     * @private\r\n     * @parma {String} level - log level\r\n     * @param {String} descriptor - to speed up search and improve understanding\r\n     * @param {Mixed} [data] - additional data\r\n     * @param {Boolean} [develop] - to tell develop environment from production\r\n     */\r\n    _record(level, descriptor, data, develop) {\r\n        var logs;\r\n        try {\r\n            logs = window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : [];\r\n            logs.push([\r\n                Date.now(),\r\n                this._namespace,\r\n                level,\r\n                descriptor,\r\n                data\r\n            ]);\r\n            if (develop) {\r\n                util.debug(this._namespace, level, descriptor, data);\r\n            }\r\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\r\n        } catch (e) {\r\n            window.localStorage.removeItem(LocalStorageLogger._database);\r\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify([]));\r\n            util.throwError('failed to write, may be localStorage is full, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * initialize protocol\r\n     * @method init\r\n     * @static\r\n     * @param {String} database - database name to use\r\n     */\r\n    static init(database) {\r\n        try {\r\n            if (!LocalStorageLogger.support) {\r\n                util.throwError('your platform does not support localstorage protocol.');\r\n            }\r\n            LocalStorageLogger._database = database || 'logline';\r\n            if (!window.localStorage.getItem(LocalStorageLogger._database)) {\r\n                window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify([]));\r\n            }\r\n            LocalStorageLogger.status = super.STATUS.INITED;\r\n        } catch (e) {\r\n            util.throwError('failed to init, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get logs in range\r\n     * if from and end is not defined, will fetch full log\r\n     * @method get\r\n     * @static\r\n     * @param {String} from - time from, unix time stamp or falsy\r\n     * @param {String} to - time end, unix time stamp or falsy\r\n     * @param {Function} readyFn - function to call back with logs as parameter\r\n     */\r\n    static get(from, to, readyFn) {\r\n        var logs, i;\r\n        try {\r\n            logs = JSON.parse(window.localStorage.getItem(LocalStorageLogger._database));\r\n\r\n            from = LoggerInterface.transTimeFormat(from);\r\n            to = LoggerInterface.transTimeFormat(to);\r\n\r\n            for (i = 0; i < logs.length; i++) {\r\n                if ((from && logs[i][0] < from) || (to && logs[i][0] > to)) {\r\n                    continue;\r\n                }\r\n\r\n                logs[i] = {\r\n                    time: logs[i][0],\r\n                    namespace: logs[i][1],\r\n                    level: logs[i][2],\r\n                    descriptor: logs[i][3],\r\n                    data: logs[i][4]\r\n                };\r\n            }\r\n            readyFn(logs);\r\n        } catch (e) {\r\n            util.throwError('failed to get, ' + e.message);\r\n            readyFn([]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * clean logs = keep limited logs\r\n     * @method keep\r\n     * @static\r\n     * @param {Number} daysToMaintain - keep logs within days\r\n     */\r\n    static keep(daysToMaintain) {\r\n        var logs;\r\n        try {\r\n            logs = !daysToMaintain ? [] : (window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : []).filter(log => {\r\n                return log.time >= (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\r\n            });\r\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\r\n        } catch (e) {\r\n            util.throwError('failed to keep, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * delete log database\r\n     * @method clean\r\n     * @static\r\n     */\r\n    static clean() {\r\n        try {\r\n            delete LocalStorageLogger.status;\r\n            window.localStorage.removeItem(LocalStorageLogger._database);\r\n        } catch (e) {\r\n            util.throwError('failed to clean, ' + e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * detect support situation\r\n     * @prop {Boolean} support\r\n     */\r\n    static get support() {\r\n        return 'localStorage' in window;\r\n    }\r\n}\r\n","import Interface from './protocols/interface';\r\nimport IndexeddbLogger from './protocols/indexeddb';\r\nimport LocalstorageLogger from './protocols/localstorage';\r\nimport * as util from './lib/util';\r\nimport config from './lib/config';\r\n\r\n\r\nclass Logline {\r\n    /**\r\n     * Logline constructor\r\n     * @constructor\r\n     * @param {String} namespace - namespace to use\r\n     * @return {Object Protocol Instance}\r\n     */\r\n    constructor(namespace) {\r\n        if (!(this instanceof Logline)) {\r\n            return new Logline(namespace);\r\n        }\r\n        try {\r\n            Logline._checkProtocol();\r\n            return new Logline._protocol(namespace);\r\n        } catch (e) {\r\n            return new Interface(namespace);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * change config\r\n     * @method config\r\n     * @param {String|Object} key - config key, or config object\r\n     * @param {Any} [value] - new config value\r\n     * @return {Void}\r\n     */\r\n    static get config() {\r\n        return config;\r\n    }\r\n\r\n    /**\r\n     * choose a protocol to initialize\r\n     * @method _initProtocol\r\n     * @private\r\n     * @static\r\n     * @param {Object Protocol Class} protocol - protocol to use, must under Logline.PROTOCOL\r\n     * @return {Object} Logline\r\n     */\r\n    static _initProtocol(protocol) {\r\n        Logline._protocol = protocol;\r\n        Logline._protocol.init(Logline._database || 'logline');\r\n    }\r\n\r\n    /**\r\n     * check protocol\r\n     * if no protocol is chosen, will try to choose an available one automatically\r\n     * if none of the protocols is available, an error will be thrown\r\n     * @method _checkProtocol\r\n     * @private\r\n     * @static\r\n     */\r\n    static _checkProtocol() {\r\n        if (!Logline._protocol) {\r\n            let protocols = Object.keys(Logline.PROTOCOL), protocol;\r\n            while ((protocol = Logline.PROTOCOL[protocols.shift()])) {\r\n                if (protocol.support) {\r\n                    Logline._initProtocol(protocol);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            util.throwError('protocols ' + protocols.join(', ').toLowerCase() + ' are not supported on this platform');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get logs in range\r\n     * if from and end is not defined, will fetch full log\r\n     * @method get\r\n     * @static\r\n     * @param {String} [from] - time from\r\n     * @param {String} [to] - time end\r\n     * @param {Function} readyFn - function to call back with logs as parameter\r\n     */\r\n    static get(from, to, readyFn) {\r\n        Logline._checkProtocol();\r\n\r\n        switch (arguments.length) {\r\n            case 1:\r\n                readyFn = from;\r\n                from = undefined;\r\n                break;\r\n            case 2:\r\n                readyFn = to;\r\n                to = undefined;\r\n                break;\r\n            case 3:\r\n            default:\r\n                break;\r\n        }\r\n\r\n        Logline._protocol.get(from, to, readyFn);\r\n    }\r\n\r\n    /**\r\n     * read all logs\r\n     * @method all\r\n     * @static\r\n     * @param {Function} readyFn - function to call back with logs as parameter\r\n     */\r\n    static all(readyFn) {\r\n        Logline.get(readyFn);\r\n    }\r\n\r\n    /**\r\n     * clean up logs = keep limited logs\r\n     * @method keep\r\n     * @static\r\n     * @param {String} daysToMaintain - specialfy days to keep, support human readable format such as '3d', '.3'\r\n     * @return {Object} Logline\r\n     */\r\n    static keep(daysToMaintain) {\r\n        Logline._checkProtocol();\r\n        Logline._protocol.keep(daysToMaintain);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * delete log database\r\n     * @method clean\r\n     * @static\r\n     * @return {Object} Logline\r\n     */\r\n    static clean() {\r\n        Logline._checkProtocol();\r\n        Logline._protocol.clean();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * choose a protocol\r\n     * @method using\r\n     * @static\r\n     * @param {Object Protocol Class} protocol - wanted protocol, should be on of Logline.PROTOCOL\r\n     * @param {String} [database] - custome database name\r\n     * @return {Object} Logline\r\n     */\r\n    static using(protocol, database) {\r\n        // protocol unavailable is not allowed\r\n        if (-1 === [IndexeddbLogger, LocalstorageLogger].indexOf(protocol)) {\r\n            util.throwError('specialfied protocol ' + (protocol ? (protocol + ' ') : '') + 'is not available');\r\n        }\r\n\r\n        // once protocol is selected, it shall not be changed during runtime\r\n        if (Logline._protocol) {\r\n            return this;\r\n        }\r\n\r\n        Logline.database(database || Logline._database);\r\n        Logline._initProtocol(protocol);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * specialfy a custome database name, in case of any conflicts\r\n     * @methd database\r\n     * @static\r\n     * @param {String} name - target database name\r\n     */\r\n    static database(name) {\r\n        Logline._database = name;\r\n    }\r\n}\r\n\r\n// export protocols for modification and mounting\r\nLogline.PROTOCOL = {\r\n    INDEXEDDB: IndexeddbLogger,\r\n    LOCALSTORAGE: LocalstorageLogger\r\n};\r\n\r\n// export protocol interface for user custom implements\r\nLogline.INTERFACE = Object.freeze(Interface);\r\n\r\n// export Logline env, just like Unix Environment variables\r\nLogline.env = {\r\n    verbose: true\r\n};\r\n\r\nexport default Logline;\r\n"],"names":["get","key","store","set","value","changes","Object","prototype","toString","call","throwError","errMessage","console","error","debug","namespace","level","descriptor","data","HAS_CONSOLE","config","verbose","LEVEL_CONSOLE_MAP","toUpperCase","INFO","Date","toLocaleString","filterFunction","obj","i","newObj","hasOwnProperty","DEFAULT_CONFIG","babelHelpers.extends","window","Interface","_namespace","develop","args","_record","database","time","relative","test","TypeError","now","replace","from","to","readyFn","daysToMaintain","Pool","_pool","handler","context","push","this","shift","IndexedDBLogger","status","LoggerInterface","STATUS","INITED","_this2","INITING","init","transaction","db","onerror","util","event","target","objectStore","add","FAILED","e","message","support","_database","babelHelpers.get","request","indexedDB","open","onsuccess","result","consume","onupgradeneeded","createObjectStore","autoIncrement","createIndex","unique","transTimeFormat","_getTransactionStore","IDBTransaction","READ_ONLY","getAll","logs","length","openCursor","cursor","continue","keep","range","delete","primaryKey","clear","clean","close","deleteDatabase","mode","IDBKeyRange","LocalStorageLogger","localStorage","getItem","JSON","parse","setItem","stringify","removeItem","filter","log","Logline","_checkProtocol","_protocol","protocol","protocols","keys","PROTOCOL","_initProtocol","join","toLowerCase","arguments","undefined","IndexeddbLogger","LocalstorageLogger","indexOf","name","INTERFACE","freeze","env"],"mappings":"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"}